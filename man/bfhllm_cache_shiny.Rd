% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache-shiny.R
\name{bfhllm_cache_shiny}
\alias{bfhllm_cache_shiny}
\title{Create Shiny Session Cache}
\usage{
bfhllm_cache_shiny(session, ttl_seconds = 3600)
}
\arguments{
\item{session}{Shiny session object}

\item{ttl_seconds}{Numeric, time-to-live in seconds (default: 3600)}
}
\value{
Cache object with same interface as \code{bfhllm_cache_create()}
}
\description{
Creates a cache object that stores data in Shiny session's userData.
Cache is automatically cleaned up when session ends.
}
\details{
\strong{Storage Location:}
Cache is stored in \code{session$userData$bfhllm_cache} as a reactiveVal.
This ensures cache is session-scoped and automatically cleaned on disconnect.

\strong{Automatic Cleanup:}
Registers \code{session$onSessionEnded()} callback to clear cache when user
disconnects, preventing memory leaks.

\strong{Idempotent:}
Safe to call multiple times - will reuse existing cache if already initialized.

\strong{Use Cases:}
\itemize{
\item Shiny applications using BFHllm for AI suggestions
\item Reduce API calls and costs within a user session
\item Consistent responses for repeated queries
}
}
\examples{
\dontrun{
# In Shiny server function
server <- function(input, output, session) {
  # Create session cache (call once per session)
  cache <- bfhllm_cache_shiny(session, ttl_seconds = 3600)

  # Use cache with LLM calls
  observeEvent(input$generate_btn, {
    key <- bfhllm_generate_cache_key(
      prompt = input$prompt_text,
      model = "gemini-2.5-flash-lite"
    )

    # Check cache first
    cached <- cache$get(key)
    if (!is.null(cached)) {
      output$result <- renderText(cached)
      return()
    }

    # Make API call
    response <- bfhllm_chat(input$prompt_text)

    # Cache response
    cache$set(key, response)

    output$result <- renderText(response)
  })
}
}

}
